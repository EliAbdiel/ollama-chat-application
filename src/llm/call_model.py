import chainlit as cl
from ollama import AsyncClient
from src.log.logger import setup_logger
from src.utils.config import (
    DEFAULT_MODEL,
    OLLAMA_API_KEY,
    OLLAMA_BASE_URL,
)

logger = setup_logger('CALL MODEL')

async def call_ollama(model, messages) -> str:
    """
    Calls the Ollama model with the provided messages and handles tool calls via MCP.
    
    Args:
        model: The name of the model to use.
        messages: The list of messages in the conversation.

    Returns:
        str: The final response generated by the model.
    """
    if not model and not messages:
        logger.error("Model name and messages are required to call Ollama.")
        raise ValueError("Model name and messages cannot be empty.")

    mcp_tools = cl.user_session.get("mcp_tools", {})
    all_tools = [tool for connection_tools in mcp_tools.values() for tool in connection_tools]
    logger.info(f"MCP All Tools: {all_tools}")
    logger.info(f"Available MCP Tools: {[tool['function']['name'] for tool in all_tools]}")
    
    client = AsyncClient(
        host=OLLAMA_BASE_URL,
        headers={"Authorization": f"Bearer {OLLAMA_API_KEY}"},
    )
    
    try:
        final_response = None

        while True:
            try:
                result = await client.chat(model=model, messages=messages, tools=all_tools)
            except Exception as e:
                logger.error(f'Error during chat call: {e}')
                break

            if result.message.content:
                logger.info(f"Received content: {str(result.message.content)[:2000]}...")
                final_response = "\n\n".join([result.message.content])
            
            messages.append(result.message)

            if result.message.tool_calls:
                logger.info(f'Tool Calls: {result.message.tool_calls}')

                for tool_call in result.message.tool_calls:
                    tool_name = tool_call.function.name
                    tool_args = tool_call.function.arguments
                    logger.info(f"Executing tool: {tool_name}, with args: {tool_args}")

                    mcp_name = None
                    for connection_name, tools in mcp_tools.items():
                        if any(tool['function']['name'] == tool_name for tool in tools):
                            mcp_name = connection_name
                            break 
                    
                    if mcp_name:
                        try:
                            mcp_sessions = getattr(cl.context.session, 'mcp_sessions', {})
                            
                            if mcp_name in mcp_sessions:
                                mcp_session = mcp_sessions[mcp_name][0]
                                tool_result = await mcp_session.call_tool(tool_name, tool_args)
                                logger.info(f"Tool result: {str(tool_result)[:2000]}...")

                                messages.append({
                                    'role': 'tool',
                                    'content': str(tool_result)[:2000 * 4],
                                    'tool_name': tool_name
                                })
                            else:
                                logger.error(f'MCP session {mcp_name} not found')
                                messages.append({
                                    'role': 'tool',
                                    'content': f'MCP session {mcp_name} not found',
                                    'tool_name': tool_name
                                })
                        except Exception as e:
                            logger.error(f'Error calling tool {tool_name}: {e}')
                            messages.append({
                                'role': 'tool',
                                'content': f'Error calling tool {tool_name}: {e}',
                                'tool_name': tool_name
                            })
                    else:
                        logger.error(f'Tool {tool_name} not found in any MCP connection')
                        messages.append({
                            'role': 'tool',
                            'content': f'Tool {tool_name} not found in any MCP connection',
                            'tool_name': tool_name
                        })
            else:
                break  # No tool calls, conversation is complete
        if final_response is not None:
            logger.info(f'Final Response: {final_response[:2000]}...')
            return final_response
        else:
            logger.warning('No final response generated')
            return None
    except Exception as e:
        logger.error(f'Unexpected error during client initialization: {e}')

async def model_name(profile:str) -> str:
    """
    Returns the model name corresponding to the given profile.
    
    Args:
        profile (str): The chat profile to use.
        
    Returns:
        str: The model name to use.
    """
    model_mapping = {
        "gpt-oss:120b-cloud": "gpt-oss:120b",
        "deepseek-v3.1:671b-cloud": "deepseek-v3.1:671b",
        "qwen3-vl:235b-cloud": "qwen3-vl:235b",
        "qwen3-coder:480b-cloud": "qwen3-coder:480b",
        "kimi-k2:1t-cloud": "kimi-k2:1t",
        "glm-4.6:cloud": "glm-4.6",
        "minimax-m2:cloud": "minimax-m2",
        "gemini-3-pro-preview": "gemini-3-pro-preview:latest",
    }

    if profile in model_mapping:
        return model_mapping[profile]
    else:
        # Return a default model if profile is None or not found
        logger.warning(f"Unknown chat profile: {profile}, using default model")
        return DEFAULT_MODEL
